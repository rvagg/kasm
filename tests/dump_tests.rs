//! Module display format tests.
//!
//! Compares `Module::to_string()` output against wasm-objdump reference output
//! stored in the `dump` section of JSON fixture files. Tests three formats:
//! Header (section listing), Details (section contents), Disassemble (code).
//!
//! JSON fixtures are generated by `tests/compile_test.mjs` from the
//! WebAssembly spec test suite using wabt's wast2json + wasm-objdump.

#[cfg(test)]
mod tests {
    use base64::{Engine as _, engine::general_purpose};
    use kasm::parser::{module, parse, reader::Reader};
    use rstest::rstest;
    use serde::Deserialize;
    use serde::de::{self, Deserializer};
    use std::collections::HashMap;
    use std::path::PathBuf;

    #[derive(Deserialize)]
    struct TestData {
        bin: HashMap<String, Base64Bytes>,
        dump: Option<HashMap<String, Dump>>,
    }

    #[derive(Debug)]
    struct Base64Bytes(Vec<u8>);

    impl<'de> Deserialize<'de> for Base64Bytes {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s: String = String::deserialize(deserializer)?;
            let decoded = general_purpose::STANDARD.decode(s).map_err(de::Error::custom)?;
            Ok(Base64Bytes(decoded))
        }
    }

    #[derive(Deserialize)]
    struct Dump {
        header: String,
        details: String,
        disassemble: String,
    }

    fn compare_format(
        section_name: &str,
        dump_field: &str,
        parsed: &module::Module,
        filename: &str,
        format: module::ParsedUnitFormat,
    ) {
        let actual = parsed.to_string(format);
        let prefix = format!("\n{filename}:\tfile format wasm 0x1\n\n{section_name}:\n\n");
        let expected = dump_field.strip_prefix(&prefix).unwrap_or(&actual);
        assert_eq!(actual, expected, "dump mismatch for {filename} {section_name}");
    }

    #[rstest]
    fn test_dump(#[files("tests/spec/*.json")] path: PathBuf) {
        let json_string =
            std::fs::read_to_string(&path).unwrap_or_else(|e| panic!("failed to read {}: {e}", path.display()));
        let test_data: TestData = serde_json::from_str(&json_string).unwrap();

        let Some(dump_data) = test_data.dump else {
            return;
        };

        let module_registry = HashMap::new();

        for (filename, dump) in &dump_data {
            let bin = &test_data.bin[filename].0;
            let module = parse(&module_registry, filename, &mut Reader::new(bin.clone()))
                .unwrap_or_else(|e| panic!("failed to parse {filename}: {e:?}"));

            compare_format(
                "Sections",
                &dump.header,
                &module,
                filename,
                module::ParsedUnitFormat::Header,
            );
            compare_format(
                "Section Details",
                &dump.details,
                &module,
                filename,
                module::ParsedUnitFormat::Details,
            );
            compare_format(
                "Code Disassembly",
                &dump.disassemble,
                &module,
                filename,
                module::ParsedUnitFormat::Disassemble,
            );
        }
    }
}
